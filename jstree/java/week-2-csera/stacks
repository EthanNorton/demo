// stacks

public static void MediaDeviceInfo(String[] args)
{
    StackOfStrings stack = new StackOfStrings();
    while (!StdIn.IsEmpty())
    {
        String s = StdIn.readstring();
        if (s.equals("-")) StdOut.print(stack.pop());
        else               stack.push(s);               
    }
}

//  more stacks

public class LinkedStackOfStrings
{
    private Node first = null;
    private class Node #private indicates an inner class .. what does this mean?
    {
        String item;
        Node next;
    }
    public boolean isEmpty()
   {     return first == null; }
   public void push(String item)
   {
    Node oldfirst = first;
    first = new Node();
    first.item = item;
    first.next = oldfirst;
   }

   public String pop()
   {
    String item = first.item;
    first = first.next;
    return item;
   }
}

public class FixedCapacityStackOfStrings
{
    private String[] s;
    private int N = 0;

    public FixedCapacityStackOfStrings(int capacity)
    {  s = new String[capacity];  }

    public boolean isEmpty()
    {  return N ==0;  }

    public void push(String item)
    {  s[N++] = item;  }

    public String pop()
    {  return s [--N];  }
}

// nulling items in stacks

public String pop()
{  return s[--N];  }


// array growth

public ResizingArrayStackOfStrings()
{  s = new String[1];   }

public void push(String item)
{
        if (N ==s.length) resize(2 * s.length);
        s[N++] = item;
}

private void resize(int capacity)
{
    String[] copy = new String[capacity];
    for (int i = 0); i < N; i++)
        copy[i] = s[i];
    s = copy;
}

// queues

private class Node
{
    String item;
    Node next;
}

public class LinkedQueueOfStrings;
{
    private Node first, last;

    private class Node
    { /* same in StackOfStrings */ }

    public boolean isEmpty()
    { return first == null; }

    public void enqueue(String item)
    {
        Node oldlast = last;
        last = new Node();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
    }

    public String dequeue()
    {
        String item = first.item;
        first = first.next
    }
}

// new coding

StackOfObjects s = new StackOfObjects();
Apple a = new Apple();
Orange b = new Orange();
S.push(a)
s.push(b)
a = (Apple) (s.pop());

// more code

public class Stack <Item>
{
    private Node first = null;
    private class Node
    {
        Item item;
        Node next;
    }
    public boolean isEmpty()
        return first == null;  }
    
    public void push(Item * item)
    {
        Node oldfirst = first;
        first = new Node();
        first.item = item;
        first.next = oldfirst;

    }

    public Item pop()
}

public Item pop()
}
    Item item= first.item;
    first = first.next;
    return item;
}

// with an array

public class FixedCapacityStack<Item>
{
    private Item[] s;
    private int N = 0;

    public FixedCapacityStack(int capacity)
    { s = new Item[capacity];   }

    public boolean isEmpty()
    {  return N == 0;  }
}

// 


